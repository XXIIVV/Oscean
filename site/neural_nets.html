<!DOCTYPE html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../links/main.css" type="text/css" rel="stylesheet"><link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<title>XXIIVV &mdash; neural nets</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>
<nav><ul><li><a href="programming_languages.html" class="parent">programming languages</a></li><li><a href="operating_systems.html">operating systems</a></li><li><a href="graphical_input.html">graphical input</a></li><li><a href="file_formats.html">file formats</a></li><li><a href="data_encoding.html">data encoding</a></li><li><a href="type_systems.html">type systems</a></li><li><a href="versioning.html">versioning</a></li></ul><ul><li><a href="assembly.html">assembly</a></li><li><a href="imperative.html">imperative</a></li><li><a href="concatenative.html">concatenative</a></li><li><a href="rewriting.html">rewriting</a></li><li><a href="functional.html">functional</a></li><li><a href="neural_nets.html" class="self">neural nets</a></li><li><a href="graphical.html">graphical</a></li></ul><ul><li><a href="mcculloch_pitts.html">mcculloch pitts</a></li></ul></nav>
<main><h2>Neural nets languages use synthetic neurons as the base computational unit.</h2>

<p>This is model of the neuron that doesn't capture all of its properties and behavior but just enough to capture the way it performs computation.</p>
<h2>A McCulloch-Pitts neuron uses threshold saturation, excitatory and inhibitory fibers.</h2>

<p>A <b>neuron</b> has incoming and outgoing connections to other neurons, it fires an output that stimulates or inhibits other neurons when it is not inhibited and the sum of its excitatory inputs is equal or higher than its <i>threshold</i>. A neuron with a threshold of zero will always fire.</p>

<img src='../media/refs/neuron.png' height='60'/>
<cite style='max-width:400px'>A neuron connected by two excitatory fibers, one inhibitory fiber, with a threshold of two.</cite>

<h3>A Notation</h3>

<p>Neural networks are typically programmed with flow diagrams, I found those to be prone to clutter. Instead, this documentation will use a textual representation, which allows networks to be created more rapidly and precisely.</p>

<pre>
A neuron*. <i style='float:right'>neuron/0</i>
</pre>

<p>In a rule, a neuron is specified with a star suffix, an excitatory connection is separated by a colon, an inhibitory connection is separated by a semi-colon, a segment is terminated by a comma, segments can be chained, everything else is ignored. A rule with no right-hand side will create neurons with a threshold of zero.</p>

<pre>
If I have matches*, and some kindling*:
	I can make a fire*: <i style='float:right'>fire/2</i>
	and have some light*. <i style='float:right'>light/1</i>

But if it's raining*;
	I cannot make a fire*.

I have matches* and kindling*. <i style='float:right'>matches/0, kindling/0</i>
</pre>

<p>In the example above, for each step of the evaluation, the <code>matches/0</code> and <code>kindling/0</code> will send excitatory pulses to <code>fire/2</code> and not terminate.</p>

<img src='../media/refs/bigtop.png'/>

<h3>Programming with Neural Nets</h3>

<img src='../media/refs/neuron_init.png' style='float:right;width:120px'/>

<p>A program will most likely involve an initial pulse. Let's say we want a neuron to fire once and turn itself off, we can connect it back onto itself with a inhibitory <i>feedback</i> fiber, and run an excitatory fiber toward the rest of the program:</p>

<pre>
Neuron*; Neuron*: output*.

The Neuron* will fire, and turn itself off.
</pre>

<h3>Logic</h3>

<p><a href='binary.html'>Binary logic</a> is implemented by a combination of inhibitory and excitatory fibers, the system welcomes the implementation of <a href='ternary.html'>ternary logic</a> gates as well. Here are the implementation of a few logic gates:</p>

<img src='../media/refs/neuron_logic.png'/>
<pre>
Create single-pulse neurons.
a*; a*.
b*; b*.

Route them to a few gates.
a*   ; NOT/0*.
a* b*: AND*.
a* b*: OR/1*.
a* b*; NOR/0*.

Activate both a* & b*.
</pre>

<h3>Loops</h3>

<p>Loops can be created by connecting neurons in a circle. In the following program, two such circles are created:</p>

<ul>
	<li>3 neurons in a circle, whenever <code>f2/1</code> fires, <code>fizz/1</code> is awakened. </li>
	<li>5 neurons in a circle, whenever <code>b4/1</code> fires, <code>buzz/1</code> is awakened.</li>
</ul>

<table border='1'>
<tr>
<th width='300'>Network</th>
<th>Evaluation</th>
</tr>
<tr>
<td>
<pre>
Init*; Init*: f0* b0*.

The fizz network.
f0*: f1*: f2*: f0* fizz*.

The buzz network.
b0*: b1*: b2*: b3*: b4*: b0* buzz*.

Init* my fizzbuzz program.
</pre>
</td><td>
<pre>
08 f2/1 b3/1 
09 f0/1 b4/1 fizz/1
10 f1/1 b0/1 buzz/1 
11 f2/1 b1/1 
12 f0/1 b2/1 fizz/1
13 f1/1 b3/1 
14 f2/1 b4/1 
15 f0/1 b0/1 fizz/1 buzz/1 
16 f1/1 b1/1 
17 f2/1 b2/1 
18 f0/1 b3/1 fizz/1
19 f1/1 b4/1 
..</pre>
</td>
</tr>
</table>

<h3>Memory Neurons</h3>

<img src='../media/refs/neuron_memory.png' style='float:right;height:140px;margin-left:15px'/>

<p>Delaying a pulse is the same as remembering it for a length of time, and so we'll call a <b>memory neuron</b> a <code>Neuron/1</code> that store a single bit of information by using an excitatory <i>feedback</i> fiber connected onto itself. To set the value of that neuron, use an a excitatory <i>start</i> fiber and inhibitory <i>stop</i> fiber. </p>

<pre style='clear:both'>
Bit*: Bit*.

controls:
- start*: Bit*.
- stop*; Bit*.
</pre>

<h3>Synchronization</h3>

<p>Each neuron delays a pulse by one moment, pulses may go out of sync if parts of a program require two pulses to converge, but <b>memory neurons</b> can synchronize pulses by holding it until another part of the network is ready to use it.</p>

<img src='../media/refs/neuron_delay.png' height='150'/>

<p>In the program below, the <code>a</code> network is 4 times slower than the <code>b</code> network, to insure that both pulses can be used together, the <code>Fast/1</code> and <code>Slow/1</code> neurons will synchronize the delayed pulse and only fire the gate neuron once both are active.</p>

<table border='1'>
<tr>
<th width='300'>Network</th>
<th>Evaluation</th>
</tr>
<tr>
<td>
<pre>
Init*; Init*: a0* b0*.

Two pulses coming in at different speeds.
a0*: a1*: a2*: a3*: Slow*: Slow*.
b0*:                Fast*: Fast*.

The pulses from Fast* and Slow* converge into:
	the gate* which waits for both:
	and then lights up the output*.

The gate* will then turn off;
	 the Fast* and Slow* neurons.

Init*.
</pre>
</td><td>
<pre>
00 Init/1 
01 a0/1 b0/1 
02 a1/1 Fast/1 
03 a2/1 Fast/1 
04 a3/1 Fast/1 
05 Slow/1 Fast/1 
06 Slow/1 Fast/1 gate/2 
07 gate/2 output/1 
08 output/1</pre>
</td>
</tr>
</table>

<h3>Capacitors</h3>

<p>Alternatively, connecting <b>memory neurons</b> in a sequence can create a capacitor that will accumulate pulses until it reaches its storage limit, output a pulse, and start over. Here is a <i>binary scaler</i> that, for every two incoming pulses, will output one pulse.</p>

<table border='1'>
<tr>
<th width='300'>Network</th>
<th>Evaluation</th>
</tr>
<tr>
<td>
<pre>
Init*; Init*: delay* split*.

Let's delay* the second pulse: 
	and connect it to split*.

The split* will share the signal: 
	with our two memory neurons A/2* B/1*.

B*: B*: A*.
A*; A*; B*.

For every two pulses entering A* and B: 
	it will fire once to output*.

Init*.
</pre>
</td><td>
<pre>
00 Init/1 
01 delay/1 split/1 
02 split/1 B/1 
03 B/1 A/2 
04 output/1</pre>
</td>
</tr>
</table>

<p>This technique can be adapted to collect more pulses at once, here is a capacitor with four memory neurons:</p>
<pre>
Init*; Init*: t0*.

Timer.
t0*: t1*: t2*: t4*: t0*.

Fork every fourth t0*:
	to input*.

Connect input*:
	to m0/1* m1/2* m2/2* m3/2*.

Connect neurons on themselves and reset.
	m0*: m0* m1*.
	m1*: m1* m2*.
	m2*: m2* m3*.
	m3*: bang*.

m3* will turn off all counting neurons;
	m0* m1* m2* m3*.

Let's Init* our program.
</pre>

<img src='../media/refs/neuron_capacitor.png'/>

<!--
<h3>Arithmetic</h3>
<p>TODO.<br/>Come back soon.</p>
-->

<h3>Implementation</h3>
<p>An implementation of the full symbolic runtime is about <a href='ansi_c.html'>150
lines of C89</a>:</p>

<div class='codeview'>
	<iframe src='../etc/neur.c.txt'></iframe>
	<pre>cc neur.c -o neur <a href='../etc/neur.c.txt' target='_blank'>view raw</a></pre>
</div>

<p>By virtue of the similarities this system shares with other <a href='rewriting.html'>rewriting systems</a>, by being programmed by specifying rules and an initial state, resembles a rewriting language enough that I thought it should classified as such.</p>

<ul>
	<li><a href='https://www.i-programmer.info/babbages-bag/325-mcculloch-pitts-neural-networks.html' target='_blank'>The McCulloch-Pitts Neuron</a></li>
	<li><a href='https://git.sr.ht/~rabbits/neur' target='_blank'>Runtime Implementation</a>, C89.</li>
	<li><a href='https://codeberg.org/CapitalEx/luneur' target='_blank'>Runtime Implementation</a>, lua.</li>
	<li><a href='https://justinmeiners.github.io/neural-nets-sim' target='_blank'>Simulator</a></li>
	<li>Illustrations from Marvin Minsky's Finite & Infinite Machines.</li>
</ul>
<ul></ul></main>
<footer>
	<a href="ethics.html"><img src="../media/icon/3arrows.svg" alt="NoNazis!"/></a>
	<a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a>
	<a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a>
	<a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> 
	<span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2008-2025</span>
	<div class="right"><a href="about.html#license">BY-NC-SA 4.0</a>
		<a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a>
	</div>
	<hr/>
</footer>
</body></html>