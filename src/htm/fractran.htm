<h2>Fractran is a computer architecture based entirely on the multiplication of fractions.</h2>

<p>A <b>prime</b> is a number that can only be divided by itself one, since these
numbers can't be divided, they can considered the DNA of other numbers. The
factoring of a number into <a href='primes.html'>prime numbers</a>, for example: 18 = 2 × 3<sup>2</sup>,
exposes values which Fractran utilizes as <i>registers</i>. There are two parts to a Fractran program:</p>

<ol>
	<li><a href='#acc'>The Accumulator</a></li>
	<li><a href='#rules'>The Fractions</a></li>
</ol>

<figure>
	<img src='../media/refs/vogue-fractran.jpg' width='300'/>
	<figcaption>Typical Fractran Programmer</figcaption>
</figure>

<h3 id='acc'>The Accumulator</h3>

<table border='1' style='float: right;margin-left: 30px;'>
	<tr><th rowspan='2'>Accumulator</th><th colspan='4'>Registers</th></tr>
	<tr><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</table>

<p>The <b>Accumulator</b> is a single number whose prime factorization holds the
value of registers(2, 3, 5, 7, 11, 13, 17, ..). For example, if the state of
the accumulator is 1008(2⁴ × 3² × 7), r2 has the value 4, r3 has the value
2, r7 has the value 1, and all other registers are unassigned.</p>

<h3>The Fraction</h3>

<img src='../media/refs/fractran.adder1.png' width='140px' style='float:right;margin-left:30px'/>

<p>A <b>Fraction</b> represents an instruction that tests one or more
registers by the prime factors of its numerator and denominator. To evaluate
the result of a rule we take the the accumulator, if multiplying it by this
<a href='fractions.html'>fraction</a> will give us an integer, we will update the accumulator with the
result.</p>

<table border='1'>
	<tr>
		<th>2/3</th>
		<th>15/256</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(<span class='numreg'>2</span><sup class='numval'>1</sup>)/(<span class='denreg'>3</span><sup class='denval'>1</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>5</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>6</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>7</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>2</sup> × <span class='denreg'>5</span><sup class='denval'>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>
if(<span class='denreg'>r3</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r3</span> -= <span class='denval'>1</span>;
	<span class='numreg'>r2</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>6</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>6</span>;
	<span class='numreg'>r3</span> += <span class='numval'>1</span>;
	<span class='numreg'>r5</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>2</span> && <span class='denreg'>r5</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>2</span>; 
	<span class='denreg'>r5</span> -= <span class='denval'>1</span>; 
	<span class='numreg'>r3</span> += <span class='numval'>1</span>; 
	<span class='numreg'>r7</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
	</tr>
</table>

<p>Operations become more readable when broken down into their primes. We can
think of every prime number as having a register which can take on non-negative
integer values. Each fraction is an instruction that operates on some of the
registers.</p>

<h3 id='notation'>A Notation</h3>

<p>While Fractran is commonly reduced to just another opaque esoteric language,
portraying it as such is doing a disservice to the relatively simple idea at
its core and to the researchers who might otherwise benefit by venturing deeper
into a relatively unexplored field of computation.</p>

<p><a href='https://wryl.tech' target='_blank'>Wryl</a>, who created <a href='modal.html'>Modal</a>, demonstrated to me an interesting connection between Fractran and <a href='rewriting.html'>rewriting languages</a>. We need only to compile our rules and point the prime registers to symbols in a dictionary to see this relationship more clearly.</p>

<pre style='clear:both'>
:: left side > right side <i>(compiled: 15/6 left.2 side.3 > side.3 right.5)</i>

AC 6 left side <i>(initial state)</i>
00 6 × 15/6 = 15, side right <i>(result state)</i>
</pre>

<p>This documentation will represent registers with names(x, y, foo-bar, baz, ..). Fractions will be
written as rewrite rules starting with <code>::</code>, a left-side, a
spacer(>) and a right-side. The notation indicates which registers to replace
on the left-side, and what to replace them with on the right-side.</p>

<img src='../media/refs/fractran.multiply.png' width='220px'/>

<h3>Programming In Fractran</h3>

<p>In a rule definition, we find symbols to the left-side of the spacer(>) to be rewritten by what is found on the right-side. Each new symbol is added to the dictionary and represented internally as a prime number.</p>

<pre>
:: flour sugar apples > apple-cake
:: apples oranges cherries > fruit-salad
:: fruit-salad apple-cake > fruit-cake

sugar oranges apples cherries flour apples
</pre>

<p>Rules are tested in a sequence from the first to the last, when a valid rewrite rule is encountered, the accumulator is updated, and the PC moved back at the first rule. In other words, it helps to visualize the fractions in a program as a list of rewrite rules that tests the accumulator against its left-side, and starts back at the top of the list after updating the accumulator when it is a match, or keep going when it does not.</p>

<pre>
AC 21450 flour sugar apples apples oranges cherries 
00 21450 × 7/30 = 5005, apples apple-cake oranges cherries 
01 5005 × 17/715 = 119, apple-cake fruit-salad 
02 119 × 19/119 = 19, fruit-cake 
</pre>

<p>Fractran has a single operation(multiply), and can be explained in 10 seconds. John Conway proposed this programming system as a way to cut through the complexity of other computation paradigms.</p>

<ul>
    <li>For each fraction in a list for which the multiplication of the accumulator and the fraction is an integer, replace the accumulator by the result of that multiplication.</li>
    <li>Repeat this rule until no fraction in the list produces an integer when multiplied by the accumulator, then halt.</li>
</ul>

<p>That's all!</p>

<figure>
	<img src='../media/refs/fractran.png' width='340'/>
	<figcaption>The Book of Numbers, <a href='https://en.wikipedia.org/wiki/John_Horton_Conway' target='_blank'>John Conway</a></figcaption>
</figure>

<h3>Logic & Arithmetic</h3>

<p>Logic in rewrite rules is typically implemented as multiple rules, where each one is a potential combination, here is <b>logical and</b> as example:</p>

<pre>
:: x y and > true
:: x and > false
:: y and > false

AC 30 x y and 
00 30 × 7/30 = 7, true
</pre>

<p>You can get the <b>sum</b> of two registers by moving the value of one register into the other. The <i>naming</i> of the x register in advance ensures that the highest number will be stored in the lowest register:</p>

<pre>
:: x <i>(Naming)</i>
:: y > x

x x x x y y
</pre>

<p>You can get the <b>difference</b> between two registers by consuming the value of two registers at once, and moving the remains to the first:</p>

<pre>
:: x y >
:: y > x

AC 576 x x x x x x y y 
00 576 × 1/6 = 96, x x x x x y 
00 96 × 1/6 = 16, x x x x
</pre>

<p>You can get the <b>product</b> of two registers by keeping an intermediate result and state register. Keeping the resulting product, by <i>naming</i> the first register, prevents the accumulator grow too much in size:</p>

<pre>
:: r acc x y <i>(Naming)</i>
:: iter acc > x iter
:: iter >
:: x y > r acc y 
:: y > iter
:: x > 

AC 8575 x x y y y 
02 8575 × 42/35 = 10290, r acc x y y y 
02 10290 × 42/35 = 12348, r r acc acc y y y 
03 12348 × 11/7 = 19404, r r acc acc y y iter 
00 19404 × 55/33 = 32340, r r acc x y y iter 
00 32340 × 55/33 = 53900, r r x x y y iter 
01 53900 × 1/11 = 4900, r r x x y y 
02 4900 × 42/35 = 5880, r r r acc x y y 
02 5880 × 42/35 = 7056, r r r r acc acc y y 
03 7056 × 11/7 = 11088, r r r r acc acc y iter 
00 11088 × 55/33 = 18480, r r r r acc x y iter 
00 18480 × 55/33 = 30800, r r r r x x y iter 
01 30800 × 1/11 = 2800, r r r r x x y 
02 2800 × 42/35 = 3360, r r r r r acc x y 
02 3360 × 42/35 = 4032, r r r r r r acc acc y 
03 4032 × 11/7 = 6336, r r r r r r acc acc iter 
00 6336 × 55/33 = 10560, r r r r r r acc x iter 
00 10560 × 55/33 = 17600, r r r r r r x x iter 
01 17600 × 1/11 = 1600, r r r r r r x x 
04 1600 × 1/5 = 320, r r r r r r x 
04 320 × 1/5 = 64, r r r r r r
</pre>

<h3>I/O</h3>

<p>To handle <b>output</b>, nothing special is to be done, the resulting accumulator at the end of an evaluation is a valid output value, some have offered schemes like <a href='https://malisper.me/building-fizzbuzz-fractran-bottom/' target='_blank'>assigning an alphabet</a> to a series of registers. The advantage with symbolic rewriting is that registers are already assigned whole tokens, so we shall use those instead.</p>

<pre>
:: print-message > "hello world"

print-message <i>>> hello world</i>
</pre>

<p>To handle <b>input</b>, rules can match for specific registers injected into the program via the accumulator once evaluation has halted.</p>

<pre>
:: detect-input ButtonA > "You pressed the A button."
:: ButtonA >

detect-input <i>>> You pressed the A button.</i>
</pre>

<p>Fractran operators are <a href='reversible_computing.html'>reversible</a>, meaning that a program can be ran backward, back to its original state. To undo an operation, evaluation is undone by inverting the numerator and denumerator:</p>

<pre>
AC 19, fruit-cake
02 19 × 119/19 = 119, apple-cake fruit-salad
01 119 × 715/17 = 5005, apples apple-cake oranges cherries
00 5005 × 30/7 = 21450, apples apples flour sugar oranges cherries
</pre>

<p>To explore Fractran further, have a look at some of the examples:</p>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/fizzbuzz.fra' target='_blank'>Fizzbuzz</a></li>
	<li><a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/tictactoe.fra' target='_blank'>Tic-Tac-Toe</a></li>
	<li><a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/life.fra' target='_blank'>Game Of Life</a></li>
</ul>

<h3>Implementation</h3>

<p>The rewriting implementation of the runtime can be implemented in about <a href='ansi_c.html'>300
lines</a>.</p>

<div class='codeview'>
	<iframe src='../etc/fractran.c.txt'></iframe>
	<pre>cc fractran.c -o fractran <a href='../etc/fractran.c.txt' target='_blank'>view raw</a></pre>
</div>

<q>The wise marvels at the commonplace.</q>
<cite>Confucius</cite>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/fractran' target='_blank'>Fractran Interpreter(C89)</a></li>
	<li><a href='https://tjwei.github.io/Fractran' target='_blank'>Fractran Interpreter(Web)</a></li>
	<li><a href='https://esoteric.codes/blog/an-intro-to-fractran' target='_blank'>Intro to Fractran</a></li>
	<li><a href='https://raganwald.com/2020/05/03/fractran.html' target='_blank'>Remembering John Conway</a></li>
	<li><a href='https://esolangs.org/wiki/Fractran' target='_blank'>On Esolang</a></li>
</ul>

<style>
	.numreg { background:#72dec2; color: black; padding: 0 2px; border-radius: 3px; }
	.numval { background:#b3f2c6; color: black; padding: 0 2px; border-radius: 3px; }
	.denreg { background:#f78f84; color: black; padding: 0 2px; border-radius: 3px; }
	.denval { background:#ffd18c; color: black; padding: 0 2px; border-radius: 3px; }
</style>
