<h2>A Fractran program is a list of fractions and
an accumulator.</h2>

<p>Any number that can't be divided by any other number, apart from itself and
one, is <a href='primes.html'>prime</a>. Since primes can't be divided, we can
think of them as the DNA of other numbers. In Fractran, each prime is a
register and their exponent is their value. </p>

<figure>
	<img src='../media/refs/vogue-fractran.jpg' width='300'/>
	<figcaption>Typical Fractran Programmer</figcaption>
</figure>

<h3>The Accumulator(AC)</h3>

<table border='1' style='float: right;margin-left: 30px;'>
	<tr><th rowspan='2'>Accumulator</th><th colspan='4'>Registers</th></tr>
	<tr><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</table>

<p>The state of the <b>Accumulator</b> is held as a single number, whose prime
factorization holds the value of registers(2, 3, 5, 7, 11, 13, 17, ..). For
example, if the state of the accumulator is 1008(2⁴ × 3² × 7), r2 has the
value 4, r3 has the value 2, r7 has the value 1, and all other registers are
unassigned. </p>

<pre style='clear:both'>
AC 18 x x y <i>(Register names: r2 = x, r3 = y)</i>
</pre>

<h3>The Rules(::)</h3>

<img src='../media/refs/fractran.adder1.png' width='140px' style='float:right;margin-left:30px'/>

<p>An <b>Rule</b> is a <a href='fractions.html'>fraction</a> that represents an
instruction that tests one or more registers by the prime factors
of its numerator and denominator. To evaluate the result of
a rule we take the state of the accumulator, if multiplying it by this fraction will
give us an integer, we will update the accumulator with the result.</p>

<table border='1'>
	<tr>
		<th>2/3</th>
		<th>15/256</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(<span class='numreg'>2</span><sup class='numval'>1</sup>)/(<span class='denreg'>3</span><sup class='denval'>1</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>5</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>6</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>7</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>2</sup> × <span class='denreg'>5</span><sup class='denval'>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>
if(<span class='denreg'>r3</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r3</span> -= <span class='denval'>1</span>;
	<span class='numreg'>r2</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>6</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>6</span>;
	<span class='numreg'>r3</span> += <span class='numval'>1</span>;
	<span class='numreg'>r5</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>2</span> && <span class='denreg'>r5</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>2</span>; 
	<span class='denreg'>r5</span> -= <span class='denval'>1</span>; 
	<span class='numreg'>r3</span> += <span class='numval'>1</span>; 
	<span class='numreg'>r7</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
	</tr>
</table>

<p>Operations become more readable when broken down into their primes. We can
think of every prime number as having a register which can take on non-negative
integer values. Each fraction is an instruction that operates on some of the
registers.</p>

<pre>
:: 3/2 x.2 > y.3 

AC 36 x x y y 
00 36 × 3/2 = 54, x y y y 
00 54 × 3/2 = 81, y y y y
</pre>

<h3>The Program</h3>

<p>A <b>Program</b> is a list of rewrite rules distributed over lines together with
an accumulator input.</p>

<img src='../media/refs/fractran.multiply.png' width='220px'/>

<pre>
:: flour sugar apples > apple-cake
:: apples oranges cherries > fruit-salad
:: fruit-salad apple-cake > fruit-cake

sugar oranges apples cherries flour apples
</pre>

<p>You can interpret a fraction as saying if the current value of each register
is greater than or equal to the value specified by the denominator, you
subtract from the registers all of the values in the denominator, add all the
values specified in the numerator. If any register is less than the value
specified in the denominator, continue to the next fraction.</p>

<pre>
AC 21450 flour sugar apples apples oranges cherries 
00 21450 × 7/30 = 5005, apples apple-cake oranges cherries 
01 5005 × 17/715 = 119, apple-cake fruit-salad 
02 119 × 19/119 = 19, fruit-cake 
</pre>

<ul>
    <li>For each fraction in the list for which the multiplication of the accumulator and the fraction is an integer, replace the accumulator by the result of that multiplication.</li>
    <li>Repeat this rule until no fraction in the list produces an integer when multiplied by the accumulator, then halt.</li>
</ul>

<figure>
	<img src='../media/refs/fractran.png' width='340'/>
	<figcaption>The Book of Numbers, <a href='https://en.wikipedia.org/wiki/John_Horton_Conway' target='_blank'>John Conway</a></figcaption>
</figure>

<h3>Rewriting</h3>

<p><a href='https://wryl.tech' target='_blank'>Wryl</a>, who created <a href='modal.html'>Modal</a>, demonstrated to me an interesting connection between Fractran and <a href='rewriting.html'>rewriting languages</a>. We need only to compile our rules and point the prime registers to symbols in a dictionary to see this relationship more clearly.</p>

<pre>
:: purple orange > brown
:: blue red > purple
:: yellow red > orange

blue yellow red red
</pre>

<p>In a rule definition, we find symbols to the left-side of the caret to be rewritten by what is found on the right-side. Each new symbol is added to the dictionary and represented internally as a prime number. The previous program will compile to something like the following internal representation:</p>

<pre>
:: 5/6 purple.2 orange.3 > brown.5 
:: 2/77 blue.7 red.11 > purple.2 
:: 3/143 yellow.13 red.11 > orange.3 

AC 11011 blue red red yellow
</pre>

<p>Rules are tested in a sequence from the first to the last, when a valid rewrite rule is encountered, the accumulator is updated, and the PC moved back at the first rule:</p>

<pre>
AC 11011 blue red red yellow 
01 11011 × 2/77 = 286, purple red yellow 
02 286 × 3/143 = 6, purple orange 
00 6 × 5/6 = 5, brown
</pre>

<h3>Logic</h3>

<p>Logic gates can be implemented using rewrite rules:</p>

<pre>
:: x y and > true
:: x and > false
:: y and > false

AC 30 x y and 
00 30 × 7/30 = 7, true
</pre>

<h3>Arithmetic</h3>

<p>You can get the <b>sum</b> of two registers by moving the value of one register into the other. The naming of the x register in advance ensures that the highest number will be stored in the lowest register:</p>

<pre>
@x

:: y > x

AC 144 x x x x y y 
00 144 × 2/3 = 96, x x x x x y 
00 96 × 2/3 = 64, x x x x x x
</pre>

<p>You can get the <b>difference</b> between two registers by consuming the value of two registers at once, and moving the remains to the first:</p>

<pre>
:: x y >
:: y > x

AC 576 x x x x x x y y 
00 576 × 1/6 = 96, x x x x x y 
00 96 × 1/6 = 16, x x x x
</pre>

<p>You can <b>multiply</b> two registers by keeping an intermediate result and state register. Keeping the resulting product in the first register prevents the accumulator grow too much in size:</p>

<pre>
@r @acc @x @y 

:: iter acc > x iter
:: iter >
:: x y > r acc y 
:: y > iter
:: x > 

AC 8575 x x y y y 
02 8575 × 42/35 = 10290, r acc x y y y 
02 10290 × 42/35 = 12348, r r acc acc y y y 
03 12348 × 11/7 = 19404, r r acc acc y y iter 
00 19404 × 55/33 = 32340, r r acc x y y iter 
00 32340 × 55/33 = 53900, r r x x y y iter 
01 53900 × 1/11 = 4900, r r x x y y 
02 4900 × 42/35 = 5880, r r r acc x y y 
02 5880 × 42/35 = 7056, r r r r acc acc y y 
03 7056 × 11/7 = 11088, r r r r acc acc y iter 
00 11088 × 55/33 = 18480, r r r r acc x y iter 
00 18480 × 55/33 = 30800, r r r r x x y iter 
01 30800 × 1/11 = 2800, r r r r x x y 
02 2800 × 42/35 = 3360, r r r r r acc x y 
02 3360 × 42/35 = 4032, r r r r r r acc acc y 
03 4032 × 11/7 = 6336, r r r r r r acc acc iter 
00 6336 × 55/33 = 10560, r r r r r r acc x iter 
00 10560 × 55/33 = 17600, r r r r r r x x iter 
01 17600 × 1/11 = 1600, r r r r r r x x 
04 1600 × 1/5 = 320, r r r r r r x 
04 320 × 1/5 = 64, r r r r r r
</pre>

<h3>Roman Numerals & Tally Marks</h3>

<p>Keeping numbers in registers quickly explodes beyond the allocated space for integers in a computer, so we can condense these values into bases, which distribute the numbers over multiple registers, and use the lowest registers for holding values we expect to be the highest.</p>

<pre>
:: I IX > X
:: I VIII > IX
:: I VII > VIII
:: I VI > VII
:: I V > VI
:: I IV > V
:: I III > IV
:: I II > III
:: I I > II

AC 1024 I I I I I I I I I I 
08 1024 × 29/4 = 7424, I I I I I I I I II 
07 7424 × 23/58 = 2944, I I I I I I I III 
06 2944 × 19/46 = 1216, I I I I I I IV 
05 1216 × 17/38 = 544, I I I I I V 
04 544 × 13/34 = 208, I I I I VI 
03 208 × 11/26 = 88, I I I VII 
02 88 × 7/22 = 28, I I VIII 
01 28 × 3/14 = 6, I IX 
00 6 × 5/6 = 5, X
</pre>

<h3>Implementation</h3>

<p>The rewriting implementation of the runtime can be implemented in about <a href='ansi_c.html'>200
lines</a>.</p>

<div class='codeview'>
	<iframe src='../etc/fractran.c.txt'></iframe>
	<pre>cc fractran.c -o fractran <a href='../etc/fractran.c.txt' target='_blank'>view raw</a></pre>
</div>

<q>The wise marvels at the commonplace.</q>
<cite>Confucius</cite>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/fractran' target='_blank'>Fractran Interpreter(C89)</a></li>
	<li><a href='https://tjwei.github.io/Fractran' target='_blank'>Fractran Interpreter(Web)</a></li>
	<li><a href='https://esoteric.codes/blog/an-intro-to-fractran' target='_blank'>Intro to Fractran</a></li>
	<li><a href='https://esolangs.org/wiki/Fractran' target='_blank'>Article on Esolang</a></li>
	<li><a href='https://esolangs.org/wiki/Collatz_function' target='_blank'>Collatz function</a></li>
	<li><a href='https://raganwald.com/2020/05/03/fractran.html' target='_blank'>Remembering John Conway</a></li>
</ul>

<style>
	.numreg { background:#72dec2; color: black; padding: 0 2px; border-radius: 3px; }
	.numval { background:#b3f2c6; color: black; padding: 0 2px; border-radius: 3px; }
	.denreg { background:#f78f84; color: black; padding: 0 2px; border-radius: 3px; }
	.denval { background:#ffd18c; color: black; padding: 0 2px; border-radius: 3px; }
</style>
