#include <stdio.h>

/*
Copyright (c) 2024 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

#define TOK_SZ 0x30
#define PRM_SZ 0x80
#define RUL_SZ 0x80
#define SRC_SZ 0x4000
#define PRIME(x) prime_lut[(x - symbols[0]) / TOK_SZ]

typedef struct Rule {
	char *a[0x10], *b[0x10];
	unsigned long int _a, _b, io, num, den;
} Rule;

Rule rules[RUL_SZ], *_rules = rules;
unsigned long prime_lut[PRM_SZ], *_prime_lut = prime_lut;
char *accumulator[PRM_SZ], **_accumulator = accumulator;
char symbols[PRM_SZ][TOK_SZ];
int symbols_len;

static unsigned long
gcd(long a, long b)
{
	if(b == 0) return a;
	return gcd(b, a % b);
}

static unsigned int
is_prime(unsigned int num)
{
	unsigned int i = 1;
	while(++i < num)
		if(gcd(i, num) > 1) return 0;
	return 1;
}

static char *
walk_ws(char *_s)
{
	char c;
	while((c = *_s) && c < 0x21) _s++;
	return _s;
}

static char *
walk_token(char *_s)
{
	char c;
	while((c = *_s) && c > 0x20) _s++;
	return _s;
}

static unsigned long
find_prime(unsigned long prime)
{
	int i = 0;
	for(i = 0; i < PRM_SZ && prime_lut[i] != prime; i++) {};
	return i;
}

static char *
find_symbol(char *token)
{
	int i;
	for(i = 0; i < symbols_len; i++) {
		char *_a = token, *_b = symbols[i];
		while(*_a == *_b) _a++, _b++;
		if(*_b == 0 && *_a < 0x21) return symbols[i];
	}
	return NULL;
}

static char *
make_symbol(char *s)
{
	int i = 0;
	char c, *sym = find_symbol(s);
	if(sym != NULL) return sym;
	if(symbols_len >= PRM_SZ) return NULL;
	sym = symbols[symbols_len++];
	while((c = *s++) && c > 0x20) sym[i++] = c;
	return sym;
}

static char *
parse_comment(char *_s)
{
	char c;
	int depth = 0;
	while((c = *_s++)) {
		if(c == '(')
			depth++;
		else if(c == ')')
			depth--;
		if(!depth) return _s + 1;
	}
	return _s;
}

static char *
parse_rule(char *_s)
{
	char c;
	int side = 0;
	Rule *r = _rules++;
	while(*_s) {
		while((c = *_s) && (c == 0x09 || c == 0x20)) _s++;
		if(*_s == 0xa || (_s[0] == ':' && _s[1] == ':')) break;
		if(*_s == '(')
			_s = parse_comment(_s);
		else if(*_s == '>')
			if(side)
				r->io = 1, _s++;
			else
				side = 1, _s++;
		else if(*_s > 0x20) {
			if(side)
				r->b[r->_b++] = make_symbol(_s), _s = walk_token(_s);
			else
				r->a[r->_a++] = make_symbol(_s), _s = walk_token(_s);
		}
	}
	if(!side) /* forward declarations */
		_rules--, r->_a = 0, r->_b = 0;
	return _s;
}

static void
print_r(FILE *f, unsigned long num, int debug)
{
	unsigned long i = 0, fac = 2;
	while(num > 1) {
		if(num % fac == 0) {
			unsigned long pow = 1;
			char *symbol = symbols[find_prime(fac)];
			num /= fac;
			while(!(num % fac)) num /= fac, pow++;
			for(i = 0; i < pow; i++) {
				if(debug)
					fprintf(f, "%s.%ld ", symbol, fac);
				else if(symbol[0] != '?' || f != stdout)
					fprintf(f, "%s ", symbol);
			}
		} else
			fac++;
	}
}

int
main(int argc, char *argv[])
{
	unsigned long acc = 1;
	unsigned int i, j, pc = 0, fuel = 0x1000;
	char src[SRC_SZ], *_src = src;
	FILE *f;
	if(argc < 2)
		return !printf("Fractran - Fractran Rewriting, 5 Sep 2024.\n");
	if(argc != 2)
		return !printf("usage: fractran input.fra\n");
	if(!(f = fopen(argv[1], "r")))
		return !printf("Source missing: %s\n", argv[1]);
	i = fread(&src, 1, SRC_SZ, f), fclose(f), src[i] = 0x0a;
	/* memorize */
	for(i = 2; i < PRM_SZ; i++)
		if(is_prime(i)) *_prime_lut++ = i;
	/* tokenize */
	while(*_src) {
		_src = walk_ws(_src);
		if(*_src == '(')
			_src = parse_comment(_src);
		else if(_src[0] == ':' && _src[1] == ':')
			_src = parse_rule(_src + 2);
		else if(*_src)
			*_accumulator++ = make_symbol(_src), _src = walk_token(_src);
	}
	/* compile */
	for(i = 0; i < _rules - rules; i++) {
		Rule *r = &rules[i];
		r->num = 1, r->den = 1;
		for(j = 0; j < r->_a; j++) r->den *= PRIME(r->a[j]);
		for(j = 0; j < r->_b; j++) r->num *= PRIME(r->b[j]);
	}
	/* print */
	for(i = 0; i < _rules - rules; i++) {
		Rule *r = &rules[i];
		fprintf(stderr, ":: %ld/%ld ", r->num, r->den), print_r(stderr, r->den, 1);
		fprintf(stderr, "> "), print_r(stderr, r->num, 1), fprintf(stderr, "\n");
	}
	/* init */
	for(i = 0; i < _accumulator - accumulator; i++)
		acc *= PRIME(accumulator[i]);
	fprintf(stderr, "\nAC %ld ", acc), print_r(stderr, acc, 0), fprintf(stderr, "\n");
	/* eval */
	if(_rules == rules) return 0;
	while(fuel--) {
		Rule *r = &rules[pc];
		if(!acc || !r->den)
			return 0;
		else if(acc % r->den)
			pc++;
		else {
			unsigned long num = acc * r->num, res = num / gcd(num, r->den);
			if(r->io) print_r(stdout, res, 0), fprintf(stdout, "\n");
			fprintf(stderr, "%02d %lu Ã— %lu/%lu = %lu, ", pc, acc, r->num, r->den, res);
			print_r(stderr, res, 0), fprintf(stderr, "\n");
			acc = res, pc = 0;
		}
	}
	return 1;
}
