#include <stdio.h>

/*
Copyright (c) 2024 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

#define PRM_SZ 0x80
#define TOK_SZ 0x30
#define RUL_SZ 0x80
#define SRC_SZ 0x4000
#define PRIME(x) prime_lut[(x - symbols[0]) / TOK_SZ]

typedef struct Fraction {
	unsigned int num, den;
} Fraction;

typedef struct Rule {
	char *a[0x10], *b[0x10];
	int _a, _b;
	Fraction f;
} Rule;

Rule rules[RUL_SZ], *_rules = &rules[0];
char src[SRC_SZ], symbols[PRM_SZ][TOK_SZ], *accsym[PRM_SZ];
int last_sym, last_acc, acc;
int prime_lut[PRM_SZ], *_prime_lut = &prime_lut[0];

static int
gcd(int a, int b)
{
	if(b == 0) return a;
	return gcd(b, a % b);
}

static Fraction
Frac(unsigned int num, unsigned int den)
{
	Fraction f;
	unsigned int d = gcd(num, den);
	f.num = num / d, f.den = den / d;
	return f;
}

static int
is_prime(int num)
{
	int i = 2;
	while(i < num)
		if(Frac(num, i++).den == 1)
			return 0;
	return 1;
}

static char *
walk_ws(char *_s)
{
	char c;
	while((c = *_s) && c < 0x21) _s++;
	return _s;
}

static char *
walk_token(char *_s)
{
	char c;
	while((c = *_s) && c > 0x20) _s++;
	return _s;
}

static int
find_prime(int prime)
{
	int i = 0;
	for(i = 0; i < PRM_SZ && prime_lut[i] != prime; i++);
	return i;
}

static char *
find_symbol(char *token)
{
	int i;
	for(i = 0; i < last_sym; i++) {
		char *_a = token, *_b = symbols[i];
		while(*_a == *_b) _a++, _b++;
		if(*_b == 0 && *_a < 0x21) return symbols[i];
	}
	return NULL;
}

static char *
make_symbol(char *s)
{
	int i = 0;
	char c, *sym = find_symbol(s);
	if(sym != NULL) return sym;
	sym = symbols[last_sym++];
	while((c = *s++) && c > 0x20) sym[i++] = c;
	return sym;
}

static char *
parse_comment(char *_s)
{
	char c;
	int depth = 0;
	while((c = *_s++)) {
		if(c == '(') depth++;
		if(c == ')') {
			depth--;
			if(!depth) break;
		}
	}
	return _s + 1;
}

static char *
parse_rule(char *_s)
{
	char c;
	int side = 0;
	Rule *r = _rules++;
	while((c = *_s)) {
		while((c = *_s) && (c == 0x09 || c == 0x20)) _s++;
		if(*_s == 0xa) break;
		if(*_s == '>')
			side = 1, _s++;
		else if(side)
			r->b[r->_b++] = make_symbol(_s), _s = walk_token(_s);
		else
			r->a[r->_a++] = make_symbol(_s), _s = walk_token(_s);
	}
	return _s;
}

static char *
parse_symbol(char *_s)
{
	accsym[last_acc++] = make_symbol(_s);
	return walk_token(_s);
}

static void
print_rule(Rule *r)
{
	int i;
	printf(":: %d/%d ", r->f.num, r->f.den);
	for(i = 0; i < r->_a; i++)
		printf("%s.%d ", r->a[i], PRIME(r->a[i]));
	printf("> ");
	for(i = 0; i < r->_b; i++)
		printf("%s.%d ", r->b[i], PRIME(r->b[i]));
	printf("\n");
}

static void
print_registers(unsigned int num)
{
	unsigned int i = 0, fac = 2;
	while(num > 1) {
		if(num % fac == 0) {
			unsigned int pow = 1;
			char *symbol = symbols[find_prime(fac)];
			num /= fac;
			while(!(num % fac)) num /= fac, pow++;
			for(i = 0; i < pow; i++)
				printf("%s ", symbol);
		} else
			fac++;
	}
	printf("\n");
}

static int
eval(void)
{
	int i, pc = 0;
	for(i = 0; i < _rules - &rules[0]; i++)
		print_rule(&rules[i]);
	printf("\nAC %d ", acc), print_registers(acc);
	while(1) {
		Rule *r = &rules[pc];
		Fraction res = Frac(acc * r->f.num, r->f.den);
		if(res.den == 1) {
			printf("%02d %u Ã— %u/%u = %u/%u, ", pc, acc, r->f.num, r->f.den, res.num, res.den);
			acc = res.num, pc = 0;
			print_registers(acc);
		} else {
			pc++;
			if(pc == _rules - &rules[0]) break;
		}
	}
	return 1;
}

int
main(int argc, char *argv[])
{
	int i, j;
	char c, *_src = src;
	FILE *f;
	if(argc < 2)
		return !printf("Fractran - Fractran Rewriting, 31 Aug 2024.\n");
	if(argc != 2)
		return !printf("usage: fractran input.fra\n");
	if(!(f = fopen(argv[1], "r")))
		return !printf("Source missing: %s\n", argv[1]);
	i = fread(&src, 1, SRC_SZ, f), fclose(f), src[i] = 0x0a;
	/* memorize */
	for(i = 2; i < PRM_SZ; i++)
		if(is_prime(i)) *_prime_lut++ = i;
	/* tokenize */
	while((c = *_src)) {
		_src = walk_ws(_src);
		if(*_src == '(')
			_src = parse_comment(_src);
		else if(_src[0] == ':' && _src[1] == ':')
			_src = parse_rule(_src + 2), _src++;
		else
			_src = parse_symbol(_src), _src++;
	}
	/* compile */
	for(i = 0; i < _rules - &rules[0]; i++) {
		Rule *r = &rules[i];
		r->f.num = 1, r->f.den = 1;
		for(j = 0; j < r->_a; j++)
			r->f.den *= PRIME(r->a[j]);
		for(j = 0; j < r->_b; j++)
			r->f.num *= PRIME(r->b[j]);
	}
	acc = 1;
	for(i = 0; i < last_acc; i++)
		acc *= PRIME(accsym[i]);
	return !eval();
}
