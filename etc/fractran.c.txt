#include <stdio.h>

/*
Copyright (c) 2024 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

#define PRM_SZ 0x80
#define RUL_SZ 0x80
#define REP_SZ 0x100
#define DIC_SZ 0x1000
#define SRC_SZ 0x4000

typedef struct Rule {
	char *a[0x10], *b[0x10];
	int _a, _b;
	unsigned long num, den;
} Rule;

char dict[DIC_SZ], *_dict = dict;
Rule rules[RUL_SZ], *_rules = rules;
unsigned long prime_lut[PRM_SZ], *_prime_lut = prime_lut;
char *syms[PRM_SZ];
int symbols_len;
unsigned long acc = 1;

static char *
scap(char *s)
{
	if(*s == '"') {
		s++;
		while(*s && *s != '"') s++;
		return s + 1;
	}
	while(*s > 0x20) s++;
	return s;
}

static char *
scpy(char *a, char *b)
{
	char *cap = scap(a);
	while(a < cap) *b++ = *a++;
	return b + 1;
}

static int
scmp(char *a, char *b)
{
	char *acap = scap(a), *bcap = scap(b);
	while(a < acap && b < bcap && *a == *b) a++, b++;
	return a == acap && b == bcap;
}

static unsigned long
gcd(unsigned long a, unsigned long b)
{
	if(b == 0) return a;
	return gcd(b, a % b);
}

static unsigned int
is_prime(unsigned int num)
{
	unsigned int i = 1;
	while(++i < num)
		if(gcd(i, num) > 1) return 0;
	return 1;
}

static unsigned long
find_prime(unsigned long prime)
{
	int i = 0;
	for(i = 0; i < PRM_SZ; i++)
		if(prime_lut[i] == prime) break;
	return i;
}

static char **
find_symbol(char *s)
{
	int i;
	for(i = 0; i < symbols_len; i++) {
		if(scmp(s, syms[i]))
			return &syms[i];
	}
	return NULL;
}

static unsigned long
PRIME(char *x)
{
	int i;
	for(i = 0; i < symbols_len; i++)
		if(scmp(x, syms[i]))
			return prime_lut[i];
	return 0;
}

static void print_s(FILE *f, char *symbol);

static char *
print_template(FILE *f, char *s)
{
	char **symbol;
	while(*s && *s != '}') {
		while(*s && *s < 0x21) s++;
		symbol = find_symbol(s);
		if(symbol != NULL) {
			if(acc % prime_lut[symbol - syms] == 0) {
				print_s(f, *symbol);
				while(*s && *s != '}') s++;
				return s + 1;
			}
			s = scap(s);
		} else
			while(*s && *s != '}' && *s > 0x21) fprintf(f, "%c", *s++);
	}
	return s + 1;
}

static void
print_s(FILE *f, char *symbol)
{
	char *_symbol = symbol;
	while(*_symbol) {
		if(*_symbol == '\\' && _symbol[1] == 'n') {
			fprintf(f, "\n"), _symbol += 2;
			continue;
		}
		if(*_symbol == '{') {
			_symbol = print_template(f, _symbol + 1);
			continue;
		}
		if(*_symbol == '#')
			break;
		if(*_symbol != '"')
			fprintf(f, "%c", *_symbol);
		_symbol++;
	}
}

static void
print_r(FILE *f, unsigned long num, int debug)
{
	unsigned long i = 0, fac = 2;
	while(num > 1) {
		if(num % fac == 0) {
			unsigned long pow = 1;
			char *symbol = syms[find_prime(fac)];
			num /= fac;
			while(!(num % fac)) num /= fac, pow++;
			for(i = 0; i < pow; i++)
				if(debug)
					fprintf(f, "%s.%lu ", symbol, fac);
				else
					print_s(f, symbol), fprintf(f, " ");
		} else
			fac++;
	}
}

static char *
parse_symbol(char **dst, char *s)
{
	char **sym = find_symbol(s);
	if(sym != NULL)
		*dst = *sym;
	else
		*dst = syms[symbols_len++] = _dict, _dict = scpy(s, _dict);
	return scap(s);
}

static char *
parse_rule(char *_s)
{
	char c;
	int side = 0, i;
	Rule *r = _rules++;
	while(*_s) {
		while((c = *_s) && (c == 0x09 || c == 0x20)) _s++;
		if(*_s == 0xa || (_s[0] == ':' && _s[1] == ':')) break;
		if(*_s == '>')
			side = 1, _s++;
		else if(*_s > 0x20)
			_s = parse_symbol(side ? &r->b[r->_b++] : &r->a[r->_a++], _s);
	}
	if(side) {
		for(i = 0, r->den = 1; i < r->_a; i++) r->den *= PRIME(r->a[i]);
		for(i = 0, r->num = 1; i < r->_b; i++) r->num *= PRIME(r->b[i]);
		fprintf(stderr, ":: %lu/%lu ", r->num, r->den), print_r(stderr, r->den, 1);
		fprintf(stderr, "> "), print_r(stderr, r->num, 1), fprintf(stderr, "\n");
	} else /* forward declarations */
		_rules--, r->_a = 0, r->_b = 0;
	return _s;
}

static void
tokenize(char *buf)
{
	char *_buf = buf, *sym;
	while(*_buf) {
		while(*_buf && *_buf < 0x21) _buf++;
		if(_buf[0] == ':' && _buf[1] == ':')
			_buf = parse_rule(_buf + 2);
		else if(*_buf)
			_buf = parse_symbol(&sym, _buf), acc *= PRIME(sym);
	}
}

static void
eval(int fuel)
{
	int pc = 0;
	if(_rules == rules) return;
	while(fuel--) {
		Rule *r = &rules[pc];
		if(!acc || !r->den)
			break;
		else if(acc % r->den)
			pc++;
		else {
			unsigned long num = acc * r->num, res = num / gcd(num, r->den);
			fprintf(stderr, "%02d %lu Ã— %lu/%lu = %lu, ", pc, acc, r->num, r->den, res);
			print_r(stderr, res, 0), fprintf(stderr, "\n");
			acc = res, pc = 0;
		}
	}
	print_r(stdout, acc, 0), fprintf(stdout, "\n");
}

int
main(int argc, char *argv[])
{
	int i;
	char c, src[SRC_SZ], buf[REP_SZ], *_buf = buf;
	FILE *f;
	if(argc < 2)
		return !printf("Fractran Rewriting, 13 Sep 2024.\nusage: fractran input.fra [arguments..]\n");
	if(!(f = fopen(argv[1], "r")))
		return !printf("Source missing: %s\n", argv[1]);
	i = fread(&src, 1, SRC_SZ, f), fclose(f), src[i] = 0x0a;
	/* memorize */
	for(i = 2; _prime_lut - prime_lut < PRM_SZ; i++)
		if(is_prime(i)) *_prime_lut++ = i;
	/* tokenize */
	tokenize(src);
	for(i = 2; i < argc; i++)
		tokenize(argv[i]);
	fprintf(stderr, "\n   %lu ", acc), print_r(stderr, acc, 1), fprintf(stderr, "\n");
	/* repl */
	eval(0x1000);
	while(fread(&c, 1, 1, stdin))
		if(c == 0xa) {
			tokenize(buf), eval(0x1000);
			_buf = buf, *_buf = 0;
		} else
			*_buf++ = c, *_buf = 0;
	return 0;
}
